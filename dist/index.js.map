{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { useState, useEffect, useReducer, useRef } from 'react';\n\nexport type GunStatic = any;\n\nexport type GunRef = any;\n\nexport type NamespacedRef = any;\n\nexport type KeyPair = {\n  pub: string;\n  priv: string;\n  epub: string;\n  epriv: string;\n};\n\nexport type Options = {\n  appKeys: string | KeyPair;\n  sea: any;\n  interval?: number;\n};\n\nexport type ActionType = {\n  type: string;\n  data: any;\n};\n\nexport type UpdateType = {\n  id: string;\n  data: any;\n};\n\nexport const encryptData = async (\n  data: any,\n  keys: string | KeyPair,\n  sea: any\n) => {\n  return keys && sea ? sea.encrypt(data, keys) : Promise.resolve(data);\n};\n\nexport const decryptData = async (\n  data: any,\n  keys: string | KeyPair,\n  sea: any\n) => {\n  return keys && sea ? sea.decrypt(data, keys) : Promise.resolve(data);\n};\n\nconst debouncedUpdates = (dispatcher, timeout = 100) => {\n  let updates: any[] = [];\n  let handler;\n  return (update: UpdateType) => {\n    updates.push(update);\n    if (!handler) {\n      handler = setTimeout(() => {\n        let newStateSlice = updates.reduce((previousState, { id, data }) => {\n          previousState[id] = data;\n          return previousState;\n        }, {});\n        dispatcher(newStateSlice);\n        updates = [];\n        handler = null;\n      }, timeout);\n    }\n\n    return () => {\n      clearTimeout(handler);\n      updates = [];\n      handler = null;\n    };\n  };\n};\n\nconst reducer = (state: Object, { data, type }: ActionType) => {\n  switch (type) {\n    case 'add':\n      return { ...state, ...data };\n    case 'update':\n      return { ...state, [data.nodeID]: data };\n    case 'remove':\n      delete state[data];\n      return { ...state };\n    default:\n      throw new Error();\n  }\n};\n\nconst useIsMounted = () => {\n  const isMounted = useRef(false);\n  useEffect(() => {\n    isMounted.current = true;\n    return () => (isMounted.current = false);\n  }, []);\n  return isMounted;\n};\n\nconst useSafeReducer = <T>(reducer, initialState): [T, Function] => {\n  const [state, dispatch] = useReducer<T>(reducer, initialState);\n  const isMounted = useIsMounted();\n\n  function safeDispatch(args) {\n    if (isMounted.current) {\n      dispatch(args);\n    }\n  }\n\n  return [state, safeDispatch];\n};\n\nexport const useGun = (Gun: GunStatic, peerList: string[]) => {\n  const [gun] = useState(\n    Gun({\n      peers: peerList,\n    })\n  );\n\n  return [gun];\n};\n\nexport const useGunNamespace = (gun: GunRef) => {\n  const [namespace, setNamespace] = useState(null);\n  if (!namespace) {\n    setNamespace(gun.user());\n  }\n  return [namespace];\n};\n\nexport const useGunKeyAuth = (\n  gun: GunRef,\n  keys: KeyPair,\n  triggerAuth: boolean = true\n) => {\n  // Will attempt to perform a login (when triggerAuth is set to true),\n  // or, if false, returns a namespaced gun node\n  const [namespacedGraph] = useGunNamespace(gun);\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n\n  gun.on('auth', () => {\n    setIsLoggedIn(true);\n  });\n\n  useEffect(() => {\n    if (namespacedGraph && !namespacedGraph.is && keys && triggerAuth) {\n      namespacedGraph.auth(keys);\n    }\n  }, [triggerAuth, namespacedGraph, keys]);\n\n  return [namespacedGraph, isLoggedIn];\n};\n\nexport const useGunKeys = (sea: any, initialValue: any) => {\n  const [keys, setKeys] = useState(initialValue);\n\n  async function getKeySet() {\n    const pair: KeyPair = await sea.pair();\n    setKeys(pair);\n  }\n\n  if (!keys) {\n    getKeySet();\n  }\n\n  return [keys, setKeys];\n};\n\nexport const useGunState = (\n  ref: GunRef,\n  opts: Options = {\n    appKeys: '',\n    sea: null,\n    interval: 100,\n  }\n) => {\n  const { appKeys, sea, interval = 100 } = opts;\n  const [gunAppGraph] = useState(ref);\n  const [fields, dispatch] = useSafeReducer<Object>(reducer, {});\n  const handler = useRef(null);\n  const isMounted = useIsMounted();\n\n  useEffect(() => {\n    const debouncedHandlers: Function[] = [];\n    if (isMounted.current) {\n      const updater = debouncedUpdates((data) => {\n        dispatch({ type: 'add', data });\n      }, interval);\n\n      gunAppGraph.on(async (encryptedField, nodeID, message, event) => {\n        let decryptedField = await decryptData(encryptedField, appKeys, sea);\n        Object.keys(decryptedField).forEach((key) => {\n          let cleanFn = updater({ id: key, data: decryptedField[key] });\n          debouncedHandlers.push(cleanFn);\n        });\n\n        if (!handler.current) {\n          handler.current = event;\n        }\n      });\n    }\n\n    return () => {\n      if (handler.current) {\n        //cleanup gun .on listener\n        handler.current.off();\n      }\n      if (debouncedHandlers.length) {\n        //cleanup timeouts\n        debouncedHandlers.forEach((c) => c());\n      }\n    };\n    // We just need to set the listener once\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Working with root node fields\n  const put = async (data: any) => {\n    let encryptedData = await encryptData(data, appKeys, sea);\n    await new Promise((resolve) =>\n      gunAppGraph.put(encryptedData, () => resolve())\n    );\n  };\n\n  const remove = async (field: string) => {\n    await new Promise((resolve) => gunAppGraph.put(null, () => resolve()));\n    dispatch({ type: 'remove', data: field });\n  };\n\n  return [fields, { put, remove }];\n};\n\nexport const useGunCollectionState = (\n  ref: GunRef,\n  opts: Options = {\n    appKeys: '',\n    sea: null,\n    interval: 100,\n  }\n) => {\n  const { appKeys, sea, interval = 100 } = opts;\n  const [gunAppGraph] = useState(ref);\n  const [collection, dispatch] = useSafeReducer<Object>(reducer, {});\n  const handler = useRef(null);\n  const isMounted = useIsMounted();\n\n  // Working with Sets\n  useEffect(() => {\n    const debouncedHandlers: Function[] = [];\n    if (isMounted.current) {\n      const updater = debouncedUpdates((data) => {\n        dispatch({ type: 'add', data });\n      }, interval);\n\n      gunAppGraph.map().on(async (encryptedNode, nodeID, message, event) => {\n        let item = await decryptData(encryptedNode, appKeys, sea);\n        if (item) {\n          let cleanFn = updater({\n            id: nodeID,\n            data: { ...item, nodeID },\n          });\n          debouncedHandlers.push(cleanFn);\n        }\n\n        if (!handler.current) {\n          handler.current = event;\n        }\n      });\n    }\n\n    return () => {\n      if (handler.current) {\n        //cleanup gun .on listener\n        handler.current.off();\n      }\n      if (debouncedHandlers.length) {\n        //cleanup timeouts\n        debouncedHandlers.forEach((c) => c());\n      }\n    };\n    // We just need to set the listener once\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const updateInSet = async (nodeID: string, data: any) => {\n    let encryptedData = await encryptData(data, appKeys, sea);\n    await new Promise((resolve) =>\n      gunAppGraph.get(nodeID).put(encryptedData, () => resolve())\n    );\n    dispatch({ type: 'update', data: { nodeID, ...data } });\n  };\n\n  const addToSet = async (data: any, nodeID?: string) => {\n    let encryptedData = await encryptData(data, appKeys, sea);\n    if (!nodeID) {\n      await new Promise((resolve) =>\n        gunAppGraph.set(encryptedData, () => resolve())\n      );\n    } else {\n      await new Promise((resolve) =>\n        gunAppGraph.get(nodeID).put(encryptedData, () => resolve())\n      );\n    }\n  };\n\n  const removeFromSet = async (nodeID: string) => {\n    await new Promise((resolve) =>\n      gunAppGraph.get(nodeID).put(null, () => resolve())\n    );\n  };\n\n  return [collection, { addToSet, updateInSet, removeFromSet }];\n};\n"],"names":["encryptData","data","keys","sea","encrypt","decryptData","decrypt","debouncedUpdates","dispatcher","timeout","handler","updates","update","push","setTimeout","newStateSlice","reduce","previousState","clearTimeout","reducer","state","Object","nodeID","Error","useIsMounted","isMounted","useRef","useEffect","current","useSafeReducer","initialState","useReducer","args","dispatch","useGunNamespace","gun","useState","namespace","setNamespace","user","Gun","peerList","peers","triggerAuth","on","setIsLoggedIn","namespacedGraph","is","auth","isLoggedIn","initialValue","pair","setKeys","getKeySet","ref","opts","appKeys","interval","debouncedHandlers","updater","type","gunAppGraph","encryptedField","message","event","decryptedField","forEach","key","cleanFn","id","off","length","c","fields","encryptedData","Promise","resolve","put","field","map","encryptedNode","item","collection","get","set"],"mappings":"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"}